<?xml version="1.0" encoding="utf-8"?>
<klayout-macro>
 <description/>
 <version/>
 <category>pymacros</category>
 <prolog/>
 <epilog/>
 <doc/>
 <autorun>true</autorun>
 <autorun-early>false</autorun-early>
 <priority>0</priority>
 <shortcut/>
 <show-in-menu>false</show-in-menu>
 <group-name/>
 <menu-path/>
 <interpreter>python</interpreter>
 <dsl-interpreter-name/>
 <text>import pya
import math


"""
This scrip implements a library of PCells and associates create functions that 
are used to instantiate a number of alignment patterns and device.



"""

class Create: 
  def align(shapes,a,b,c):
    """
    Produce the defualt alignment marks and inserts it into the specified shapes.

    Parameters:
    - shapes: 
        The target shape container.
    - a: Float (um)
        The width of the lines of cross.
    - b: Float (um)
        The length of the cross's arms.
    - c: Float (um)
        The length of the converging portion of the alignment mark.

    Returns:
    None
    """
    # Define one arm and rotate 90deg 3 times
    
    # Define a 90deg rotation
    t = pya.DTrans(1)
    #Define points
    pts = []
    pts.append(pya.DPoint(0, 0)) 
    pts.append(pya.DPoint(c, a/2))
    pts.append(pya.DPoint(c + b, a/2))
    pts.append(pya.DPoint(c + b, -a/2))
    pts.append(pya.DPoint(c, -a/2))
    
    # create the shape
    for j in range(3):
      for i in range(len(pts)-5, len(pts)):
        pts.append(pts[i] *t)
    # Insert a polygon in the shape using the points
    shapes.insert(pya.DSimplePolygon(pts))
    
    
  def bracket(shapes, line_width, width, transform=pya.DTrans(0, False, 0, 0)):
    """
    Produce a bracket shape and insert it into the specified shapes container.

    Parameters:
    - shapes: 
       The target shape container.
    - line_width: Float (um)
       The width of the bracket lines.
    - width: Float (um)
       The overall width of the bracket.
    - transform: pya.DTrans, Optional
       The transformation to be applied to the bracket shape.

    Returns:
    None
    """
    gap = line_width
    t = pya.DTrans(1)

    # Define the bracket points for one arm
    bracket_points = [
        pya.DPoint(line_width / 2 + gap, line_width / 2 + gap),
        pya.DPoint(width / 2, line_width / 2 + gap),
        pya.DPoint(width / 2, line_width + gap),
        pya.DPoint(line_width + gap, line_width + gap),
        pya.DPoint(line_width + gap, width / 2),
        pya.DPoint(line_width / 2 + gap, width / 2),
    ]

    # Create the bracket shape
    bracket_shape = pya.DSimplePolygon(bracket_points)

    # Insert the bracket arm into the specified shapes with the provided transformation, then rotate 90deg
    for _ in range(4):
        shapes.insert(bracket_shape.transformed(transform))
        bracket_shape = bracket_shape.transformed(t)
        
        

  def cross(shapes, line_width, width, transform=pya.DTrans(0, False, 0, 0)):
    """
    Produce a cross shape and insert it into the specified shapes.

    Parameters:
    - shapes: 
        The target shape container.
    - line_width: Float (um)
        The width of the cross lines.
    - width: Float (um)
        The overall width of the cross.
    - transform: pya.DTrans, optional
        The transformation to be applied to the cross shape. Default is none

    Returns:
    None
    """
    half_line_width = line_width / 2
    half_width = width / 2

    # Define the list of points for the perimeter of the cross shape
    cross_points = [
        pya.DPoint(half_width, -half_line_width),  # Top right
        pya.DPoint(half_line_width, -half_line_width),  # Top right inner
        pya.DPoint(half_line_width, -half_width),  # Top right inner
        pya.DPoint(-half_line_width, -half_width),  # Top left inner
        pya.DPoint(-half_line_width, -half_line_width),  # Top left inner
        pya.DPoint(-half_width, -half_line_width),  # Top left
        pya.DPoint(-half_width, half_line_width),   # Bottom left
        pya.DPoint(-half_line_width, half_line_width),   # Bottom left inner
        pya.DPoint(-half_line_width, half_width),  # Bottom left inner
        pya.DPoint(half_line_width, half_width),  # Bottom right inner
        pya.DPoint(half_line_width, half_line_width),  # Bottom right inner
        pya.DPoint(half_width, half_line_width),   # Bottom right
    ]

    # Create the cross shape using the list of points
    cross_shape = pya.DSimplePolygon(cross_points)

    # Insert the cross shape into the specified shapes with the provided transformation
    shapes.insert(cross_shape.transformed(transform))
 
        
  def hallbar(shapes, side_contact_gap, side_contact_length, side_contact_width, main_contact_length, main_contact_width, transform=pya.DTrans(0, False, 0, 0), n_side_contacts=4):
    """
    Produce a hallbar and insert it into the specified shapes.

    Parameters:
    - shapes: 
        The target shape container.
    - side_contact_gap: Float (um)
        The distance in um between the edge of one side contact and another
    - side_contact_length: Float (um)
        The length of the side contacts in um
    - side_contact_width: Float (um)
        The width of the side contacts in um
    - main_contact_length: Float (um)
        The length in um of the main contacts measured from the end of the side contacts.
    - main_contact_width: Float (um)
        The width in um of the main contacts
    - transform: pya.DTrans, Optional
        Transform that is applied to the structure when it is inserted into the shape
    - n_side_contacts: int, Optional, default 4
        The number of side contacts (is rounded down to nearest even number)

    Returns:
    None
    """
    # Define the points for the hall bar
    #define starting points (top left hand corner) such that the center of the structure will be a 0,0
    x0 = - ( 2* main_contact_length  + side_contact_gap*(n_side_contacts/2 - 1) + side_contact_width*( n_side_contacts/2 ))/2 ; y0 = main_contact_width/2;
    
    x = [x0]
    y = [y0]
    
    #define the points of the top trace of structure
    for i in range(int(n_side_contacts/2)):
      x_offset = x0 +  (side_contact_gap +  side_contact_width)* i + main_contact_length
      
      x.append(x_offset)
      y.append(y0)
      
      x.append(x_offset)
      y.append(y0 + side_contact_length)
      
      x.append(x_offset + side_contact_width)
      y.append(y0 + side_contact_length)
      
      x.append(x_offset + side_contact_width)
      y.append(y0)
    
    x.append(x_offset + side_contact_width + main_contact_length)
    y.append(y0)
    
    #We then mirror the y points across the x-axis by multiplying them by -1 and reverse so that the list gose clockwise around the shape
    
    y2 = [-i for i in reversed(y)]
    x2 = [i for i in reversed(x)]
    
    x += x2
    y += y2
    
    #We then convert to dpoints
    
    pts = [pya.DPoint(x[i],y[i]) for i , xi in enumerate(x)]
     
    #We then add the two x and y lists together 
      
  # Create the hall bar shape using all the points
    hall_bar = pya.DSimplePolygon(pts)
    shapes.insert(hall_bar.transformed(transform))
 


  def lines(shapes, d0, dd, h, w0, dw, n):

    """
    Produce lines of a given height (h) and varying length and inserts it into the specified shapes.

    Parameters:
    - shapes: 
        The target shape container.
    - d0: Float (um)
        The initial spacing between lines 
    - dd: Float (um)
        The increment by which the spacing increases each iteration 
    - h: Float (um)
        The height of the lines 
    - w0: Float (um)
        The initial width lines 
    - dw: Float (um)
        The increment by which the width of the lines increases each iteration
    - n: int
        The number of lines


    Returns:
    None
    """
    x = 0
    d = d0
    w = w0
    for i in range(0,n):
      shapes.insert(pya.DBox(x, 0, w + x ,h))
      x = x + d + w
      d = d + dd 
      
      w = w + dw
      
  def lines_triangle_hats(shapes, d0, dd, h, w0, dw, n, th):    
  
    """
    Produce lines of a given height (h), a triangle on top of height th, and varying length and inserts it into the specified shapes.

    Parameters:
    - shapes: 
        The target shape container.
    - d0: Float (um)
        The initial spacing between lines 
    - dd: Float (um)
        The increment by which the spacing increases each iteration 
    - h: Float (um)
        The height of the lines 
    - w0: Float (um)
        The initial width lines 
    - dw: Float (um)
        The increment by which the width of the lines increases each iteration
    - n: int
        The number of lines
    - th: int
        The height of the triangle tip above the rectangle


    Returns:
    None
    """
  
    x = 0
    d = d0
    w = w0
    
    
    for i in range(0, n):
      pts = []
      pts.append(pya.DPoint(x, 0))
      pts.append(pya.DPoint(x, h))
      pts.append(pya.DPoint(x + w / 2, h + th))
      pts.append(pya.DPoint(x + w, h))
      pts.append(pya.DPoint(x + w, 0))
      shapes.insert(pya.DPolygon(pts))
      
      x = x + d + w
      d = d + dd 
      w = w + dw

  def lines_arc_hats(shapes, d0, dd, h, w0, dw, n, np):   
  
    
    """
    Produce lines of a given height (h), an arc on top of with resolution np, and varying length and inserts it into the specified shapes.

    Parameters:
    - shapes: 
        The target shape container.
    - d0: Float (um)
        The initial spacing between lines 
    - dd: Float (um)
        The increment by which the spacing increases each iteration 
    - h: Float (um)
        The height of the lines 
    - w0: Float (um)
        The initial width lines 
    - dw: Float (um)
        The increment by which the width of the lines increases each iteration
    - n: int
        The number of lines
    - np: int
        The resolution of the arc on top of each line
        
    Returns:
    None
    """
   
    x = 0
    d = d0
    w = w0
    pi = math.pi
    
    for i in range(0, n):
      pts = []
      pts.append(pya.DPoint(x, 0))
      pts.append(pya.DPoint(x + w, 0))
      pts.append(pya.DPoint(x + w, h))
      for i in range(0, np):
        pts.append(pya.DPoint(x + w / 2 + math.cos(pi * i / np) * w / 2, h + math.sin(pi * i / np) * w / 2))
      
      pts.append(pya.DPoint(x, h))
      shapes.insert(pya.DPolygon(pts))
      
      x = x + d + w
      d = d + dd 
      w = w + dw
      
      
      
  def concentric_circles(shapes, n, w, d, np):
    """
    *** High number of circles with high resolution will be slow to calculate ***
    Produce  number (n) of concentric "donuts" of a given width (w), spacing (d), with resolution (np) and inserts it into the specified shapes.

    Parameters:
    - shapes: 
        The target shape container.
    - w: Float (um)
        The initial width of the "donuts"
    - n: int
        The number of donuts
    - d: Float (um)
        The spacing between the donuts
    - np: int
        The resolution of the donuts 
        
    Returns:
    None
    """
  
    r_int = 0
    r_ext = w
    for i in range(0, n):
      pts = []
      for i in range(0, np + 1):
        pts.append(pya.DPoint(r_ext * math.sin(2 * math.pi * i / np), r_ext * math.cos(2 * math.pi * i/ np)))
      for i in range(np, -1, -1):
        print(i)
        pts.append(pya.DPoint(r_int * math.sin(2 * math.pi * i / np), r_int * math.cos(2 * math.pi * i / np)))
      shapes.insert(pya.DPolygon(pts))
      r_int = r_int + w + d
      r_ext = r_ext + w + d
      
  def concentric_squares(shapes, n, w, d):
  
    """
    Produce a number (n) of concentric square of a given width (w) and spacing (d) and inserts it into the specified shapes.

    Parameters:
    - shapes: 
        The target shape container.
    - w: Float (um)
        The initial width of the square
    - n: int
        The number of squares
    - d: Float (um)
        The spacing between the squares
        
    Returns:
    None
    """
    
    y_0 = 0
    y_1 = w / 2
    y_2 = w / 2
    y_3 = -w / 2
    y_4 = -w / 2
    y_5 = 0
    y_6 = 0
    y_7 = -w / 2 - d
    y_8 = -w / 2 - d
    y_9 = w / 2 + d
    y_10 = w / 2 + d
    y_11 = 0
    
    x_0 = w / 2
    x_1 = w / 2
    x_2 = -w / 2
    x_3 = -w / 2
    x_4 = w / 2
    x_5 = w / 2
    x_6 = w / 2 + d
    x_7 = w / 2 + d
    x_8 = -w / 2 - d
    x_9 = -w / 2 - d
    x_10 = w / 2 + d
    x_11 = w / 2 + d
    
    for i in range(0, n):
      pts = []
      pts.append(pya.DPoint(x_0, y_0))
      pts.append(pya.DPoint(x_1, y_1))
      pts.append(pya.DPoint(x_2, y_2))
      pts.append(pya.DPoint(x_3, y_3))
      pts.append(pya.DPoint(x_4, y_4))
      pts.append(pya.DPoint(x_5, y_5))
      pts.append(pya.DPoint(x_6, y_6))
      pts.append(pya.DPoint(x_7, y_7))
      pts.append(pya.DPoint(x_8, y_8))
      pts.append(pya.DPoint(x_9, y_9))
      pts.append(pya.DPoint(x_10, y_10))
      pts.append(pya.DPoint(x_11, y_11))
      shapes.insert(pya.DPolygon(pts))
      
      y_0 = 0
      y_1 = y_1 + w + d
      y_2 = y_2 + w + d
      y_3 = y_3 - w - d
      y_4 = y_4 - w - d
      y_5 = 0
      y_6 = 0
      y_7 = y_7 - w - d
      y_8 = y_8 - w - d
      y_9 = y_9 + w + d
      y_10 = y_10 + w + d
      y_11 = 0
    
      x_0 = x_0 + w + d
      x_1 = x_1 + w + d
      x_2 = x_2 - w - d
      x_3 = x_3 - w - d
      x_4 = x_4 + w + d
      x_5 = x_5 + w + d
      x_6 = x_6 + w + d
      x_7 = x_7 + w + d
      x_8 = x_8 - w - d
      x_9 = x_9 - w - d
      x_10 = x_10 + w + d
      x_11 = x_11 + w + d
      
      
            
        
    
  def siemens_star(shape, n, ru):
    """
    Produce a Siemens star for resolution tests and inserts it into the specified shapes.

    Parameters:
    - shapes: 
        The target shape container.
    - n: int
        The number of spokes
    - ru: Float (um)
        The radius of the Siemens star

    Returns:
    None
    """
    # This is the main part of the implementation: create the layout
    verts  = n * 2
    # compute the Siemens_star
    da = math.pi * 2 / verts
    #pts = [ pya.DPoint(self.ru * math.cos(i * da), self.ru * math.sin(i * da)) for i in range(0, self.n) ]
    pts = []
    for i in range(0, verts):
      if i % 2 == 0:
        pts.append( pya.DPoint(0, 0))
      else:
        pts.append( pya.DPoint(ru * math.cos(i * da), ru * math.sin(i * da)))
        pts.append( pya.DPoint(ru * math.cos((i + 1) * da), ru * math.sin((i + 1) * da)))
    # create the shape
    shape.insert(pya.DPolygon(pts))
      

  def text(shape = None, dbu = 0.001, string = "missing text", text_width = 100, x = 0, y = 0):
    """
    Produce text and inserts it into the specified shapes. 

    Had to be implemented in a strange way due to a bug in Klayout's code. May break with future updates. 

    Parameters:
    - shapes: 
        The target shape container.
    - dbu: Float, optional 
        The database unit of the layout
    - string: str, optional
        The text to add
    - text_width: Float (um)
        Width of the text in um, might give error if text width equals 0
    - x: Float (um), optional 
        x shift of the text
    - y: Float (um), optional
        y shift of the text



    Returns:
    None
    """

    if shape == None:
      print("No shape provided") 
      return
    if text_width == 0:
      print("text_width cannot be 0") 
      return
      
    text = pya.TextGenerator.default_generator().text(string, dbu / (10*text_width))
    text.move(x/dbu, y/dbu)
    shape.insert(text)
      
  def vernier(shapes, spacing, width, height, n, transform, mark_center):
    """
    Produce one side of a Vernier scale and inserts it into the specified shapes.

    Parameters:
    - shapes: 
        The target shape container.
    - spacing: Float (um)
        The spacing between the tick marks (center-to-center)
    - width: Float (um)
        The width of the tick marks 
    - height: Float (um)
        The height of the tick marks
    - n: int
        The number of tick marks
    - transform: pya.DTrans 
        Transform that is applied to the structure when it is inserted into the shape
    - mark_center: bool
        Whether to mark the center tick by making it twice as tall, only if n is an odd number.


    Returns:
    None
    """

    x = - (spacing*(n-1) + width)/2 
    for i in range(n):
      box = pya.DBox(x, -height/2, x + width ,height/2)
      x = x + spacing
      shapes.insert(box.transformed(transform))
    
    if (mark_center and n % 2 &gt; 0):
      shapes.insert(pya.DBox(-width/2, -(height + width) , width/2, -(height/2 + width) ).transformed(transform))

    
    
     
  def vernier_align(shapes1,shapes2, msd, lc, line_width, line_height, overlap, n, mark_center, center_cross = False):
    """
    Produce a alignment mark with Vernier calipers on all sides and inserts it into the specified shapes.

    Parameters:
    - shapes1: 
        The first target shape container. Contains the center alignment mark with the main scale 
    - shapes2: 
        The second target shape container. Contains the outer alignment mark with the Vernier scale
    - msd: Float (um)
        The main scale devision 
    - lc: Float (um)
        The least count, the resolution of the Vernier scale
    - line_width: Float (um)
        The width of the tick marks 
    - line_height: Float (um)
        The height of the tick marks
    - n: int
        The number of tick marks
    - overlap: Float (um)
        The overlap of the two scales
    - mark_center: bool
        Whether make the center tick of the scales longer
    - mark_center: bool
        Whether to make the center of the alignment make with a cross and a bracket ( width = line_width, height = 2*line_height)   

    Returns:
    None
    """
    vc = msd - lc
    width = (n + 2) * msd 
    rotate = pya.DTrans(1,False, 0,0)
    
    t1 =  pya.DTrans(0,False, 0,-width/2)
    t2 = pya.DTrans(2,False, 0 ,-width/2 + line_height - overlap)
    #side 1
    
    #Produce each of the four sides and then rotate 90 deg to produce the next 
    for _ in range(4):
      Create.vernier(shapes = shapes1, spacing = msd, width =  line_width,height =  line_height ,n = n, transform = t1,mark_center =  mark_center)
      Create.vernier(shapes = shapes2, spacing = vc, width =  line_width,height =  line_height ,n = n, transform = t2,mark_center =  mark_center)
      t1 = rotate * t1
      t2 = rotate * t2
    if center_cross:
      Create.bracket(shapes = shapes1, line_width = line_width, width = 2*line_height)
      Create.cross(shapes = shapes2, line_width = line_width, width = 2*line_height)   
    
    
  def ruler(th, tw, lw,length,d,major):
    """
    Produce a ruler with defined distances between ticks and returns a simple polygon  

    Parameters:
    - th: Float (um)
        The height of the ticks
    - tw: Float (um)
        The width of the ticks
    - lw: Float (um)
        The width of the line connecting the ticks (ruler base)
    - length: Float (um)
        The length of the ruler
    - d: Float (um)
        The distance between ticks (center-to-center)
    - major: int
        The number of minor ticks between major ticks, e.g. every 10th tick is taller

    Returns:
    pya.DSimplePolygon
    """

    n_teeth = int(length / d)
    x0 = - (length + d)/2
    x = x0
    pts = []
    pts.append(pya.DPoint(x0, 0))
    pts.append(pya.DPoint(x0, lw))
    for i in range(0, n_teeth):
      x = x + d 
      pts.append(pya.DPoint(x - tw/2, lw))
      if i % major == 0:
        pts.append(pya.DPoint(x - tw/2, lw + th * 2))
        pts.append(pya.DPoint(x + tw - tw/2, lw + th * 2))  
      else:
        pts.append(pya.DPoint(x - tw/2, lw + th))
        pts.append(pya.DPoint(x + tw - tw/2, lw + th))
      pts.append(pya.DPoint(x + tw - tw/2, lw))
    pts.append(pya.DPoint(x + d, lw))
    pts.append(pya.DPoint(x + d, 0))
  
    return pya.DSimplePolygon(pts)
    
    
    
    


###############################################################################
#              PCELL DECLARATIONS
##################################################################################    
    
    
    
    



class Align_default(pya.PCellDeclarationHelper):
  """
  The PCell declaration for the default alignment mark
  """

  def __init__(self):

    # Important: initialize the super class
    super(Align_default, self).__init__()

    # declare the parameters
    self.param("l", self.TypeLayer, "Layer 1")
    self.param("s", self.TypeShape, "", default = pya.DPoint(0, 0))
    self.param("obj", self.TypeInt, "Objective", choices = [ [ "0.5x", 0 ], [ "1x", 1 ], [ "2.5x", 2 ], [ "5x", 3 ], [ "10x", 4 ] ], default = 0)
    self.param("vernier", self.TypeBoolean, "Add vernier", default = False)  
    self.param("l2", self.TypeLayer, "Layer 2")
    self.param("label", self.TypeString, "Label", default = None) 
    
    #Provide scaler value that assignes whet quadrent the label is in 
    self.param("text_x", self.TypeDouble, "Label X", default = -0.8) 
    self.param("text_y", self.TypeDouble, "Label Y", default = 0.8  ) 

  def display_text_impl(self):
    # Provide a descriptive text for the cell
    
    objname = [ "0.5x","1x","2.5x","5x","10x"]
    return "Align(L=" + str(self.l) + ", obj = " + objname[self.obj] + ")"

  def produce_impl(self):
    obj = self.obj 
    A = [250, 140, 50, 25, 15]
    B = [2000, 1000, 400, 200, 100]
    C = [1000, 500, 200, 100, 50]
    D = [40,20,9,5,2.2]
    
    shapes = self.cell.shapes(self.l_layer)
    Create.align(shapes,A[obj],B[obj],C[obj])
    shapes = self.cell.shapes(self.l2_layer)
    Create.align(shapes,A[obj],B[obj],C[obj])
    
    msd_list = [200,100,40,20,10]
    lc_list = [20,10,4,2,1]
    line_width_list = D
    line_height_list = A 
    overlap_list = [100,50,20,10,5]
    #n_list = [21,21,21,21,21]
    if self.label is not None:
      Create.text(shape = self.cell.shapes(self.l_layer), dbu = self.layout.dbu,  string = self.label, text_width = D[obj], x = ( B[obj] + C[obj]) * self.text_x, y =  ( B[obj] + C[obj])*self.text_y )
      
    if self.vernier:
      n = math.ceil(1.2*2*(B[obj]+C[obj])/msd_list[obj]) // 2 * 2 + 1
      Create.vernier_align(shapes1=self.cell.shapes(self.l_layer),shapes2=self.cell.shapes(self.l2_layer), msd=msd_list[obj], lc=lc_list[obj], line_width=line_width_list[obj], line_height=line_height_list[obj], overlap=overlap_list[obj], n = n, mark_center=True)
      


class HallBar(pya.PCellDeclarationHelper):
  """
  The PCell declaration for the hall bar
  """

  def __init__(self):

    # Important: initialize the super class
    super(HallBar, self).__init__()

    # declare the parameters
    self.param("l", self.TypeLayer, "Layer")
    self.param("l2", self.TypeLayer, "Layer 2")
    self.param("s", self.TypeShape, "", default = pya.DPoint(0, 0))
    self.param("side_contact_gap", self.TypeDouble, "Side contact gap", default = 300)
    self.param("side_contact_length", self.TypeDouble, "Side contact length", default = 200)
    self.param("side_contact_width", self.TypeDouble, "Side contact width", default = 100)
    self.param("main_contact_length", self.TypeDouble, "Main contact length", default = 200)
    self.param("main_contact_width", self.TypeDouble, "Main contact width", default = 100)
    self.param("n_side_contacts", self.TypeInt, "Number of side contacts", default = 4)  


  def display_text_impl(self):
    # Provide a descriptive text for the cell
    return "HallBar(L=" + str(self.l) + ",Gap=" + ('%.3f' % self.side_contact_gap) + ")"

  def produce_impl(self):
    shapes1 = self.cell.shapes(self.l_layer)
    Create.hallbar(shapes = shapes1 ,side_contact_gap = self.side_contact_gap, side_contact_length = self.side_contact_length, side_contact_width = self.side_contact_width , main_contact_length = self.main_contact_length, main_contact_width = self.main_contact_width , n_side_contacts = self.n_side_contacts)
      




    
class Lines(pya.PCellDeclarationHelper):
  """
  The PCell declaration for the Lines
  """

  def __init__(self):

    # Important: initialize the super class
    super(Lines, self).__init__()

    # declare the parameters
    self.param("l", self.TypeLayer, "Layer")
    self.param("s", self.TypeShape, "", default = pya.DPoint(0, 0))
    self.param("h", self.TypeDouble, "Height", default = 100)
    self.param("w0", self.TypeDouble, "Initial Width", default = 10)
    self.param("dw", self.TypeDouble, "Change in width", default = 0)
    self.param("d0", self.TypeDouble, "Initial Spacing", default = 100)
    self.param("dd", self.TypeDouble, "Change in spacing", default = 0)
    self.param("n", self.TypeInt, "Number of lines", default = 10)     
    # this hidden parameter is used to determine whether the radius has changed
    # or the "s" handle has been moved
    self.param("ru", self.TypeDouble, "Radius", default = 0.0, hidden = True)
    self.param("rd", self.TypeDouble, "Double radius", readonly = True)

  def display_text_impl(self):
    # Provide a descriptive text for the cell
    return "Lines(L=" + str(self.l) + ",H=" + ('%.3f' % self.h) + ")"

  def produce_impl(self):
    Create.lines(shapes = self.cell.shapes(self.l_layer), d0 = self.d0, dd = self.dd, h = self.h, w0 = self.w0, dw = self.dw, n = self.n)
    
class Lines_Triangle_Hats(pya.PCellDeclarationHelper):
  """
  The PCell declaration for the Lines_Triangle_Hats
  """

  def __init__(self):

    # Important: initialize the super class
    super(Lines_Triangle_Hats, self).__init__()

    # declare the parameters
    self.param("l", self.TypeLayer, "Layer")
    self.param("s", self.TypeShape, "", default = pya.DPoint(0, 0))
    self.param("h", self.TypeDouble, "Height", default = 100)
    self.param("w0", self.TypeDouble, "Initial Width", default = 10)
    self.param("dw", self.TypeDouble, "Change in width", default = 0)
    self.param("d0", self.TypeDouble, "Initial Spacing", default = 100)
    self.param("dd", self.TypeDouble, "Change in spacing", default = 0)
    self.param("n", self.TypeInt, "Number of lines", default = 10)     
    self.param("th", self.TypeDouble, "Triangle Tip Height", default = 10)
    # this hidden parameter is used to determine whether the radius has changed
    # or the "s" handle has been moved
    self.param("ru", self.TypeDouble, "Radius", default = 0.0, hidden = True)
    self.param("rd", self.TypeDouble, "Double radius", readonly = True)

  def display_text_impl(self):
    # Provide a descriptive text for the cell
    return "Lines(triangle hats) (L=" + str(self.l) + ",H=" + ('%.3f' % self.h) + ")"

  def produce_impl(self):
    Create.lines_triangle_hats(shapes = self.cell.shapes(self.l_layer), d0 = self.d0, dd = self.dd, h = self.h, w0 = self.w0, dw = self.dw, n = self.n, th = self.th)

class Lines_Arc_Hats(pya.PCellDeclarationHelper):
  """
  The PCell declaration for the Lines_Arc_Hats
  """

  def __init__(self):

    # Important: initialize the super class
    super(Lines_Arc_Hats, self).__init__()

    # declare the parameters
    self.param("l", self.TypeLayer, "Layer")
    self.param("s", self.TypeShape, "", default = pya.DPoint(0, 0))
    self.param("h", self.TypeDouble, "Height", default = 100)
    self.param("w0", self.TypeDouble, "Initial Width", default = 10)
    self.param("dw", self.TypeDouble, "Change in width", default = 0)
    self.param("d0", self.TypeDouble, "Initial Spacing", default = 100)
    self.param("dd", self.TypeDouble, "Change in spacing", default = 0)
    self.param("n", self.TypeInt, "Number of lines", default = 10)     
    self.param("np", self.TypeInt, "Number of Arc Points", default = 32)
    # this hidden parameter is used to determine whether the radius has changed
    # or the "s" handle has been moved
    self.param("ru", self.TypeDouble, "Radius", default = 0.0, hidden = True)
    self.param("rd", self.TypeDouble, "Double radius", readonly = True)

  def display_text_impl(self):
    # Provide a descriptive text for the cell
    return "Lines (arc hats) (L=" + str(self.l) + ",H=" + ('%.3f' % self.h) + ")"

  def produce_impl(self):
    Create.lines_arc_hats(shapes = self.cell.shapes(self.l_layer), d0 = self.d0, dd = self.dd, h = self.h, w0 = self.w0, dw = self.dw, n = self.n, np = self.np)

    
class Concentric_Circles(pya.PCellDeclarationHelper):
  """
  The PCell declaration for the Lines_Arc_Hats
  """

  def __init__(self):

    # Important: initialize the super class
    super(Concentric_Circles, self).__init__()

    # declare the parameters
    self.param("l", self.TypeLayer, "Layer")
    self.param("s", self.TypeShape, "", default = pya.DPoint(0, 0))
    self.param("n", self.TypeInt, "Number of circles", default = 10)
    self.param("w", self.TypeDouble, "Line width", default = 10)
    self.param("d", self.TypeDouble, "Spacing", default = 10)  
    self.param("np", self.TypeInt, "Number of arc points", default = 64)
    # this hidden parameter is used to determine whether the radius has changed
    # or the "s" handle has been moved
    self.param("ru", self.TypeDouble, "Radius", default = 0.0, hidden = True)
    self.param("rd", self.TypeDouble, "Double radius", readonly = True)

  def display_text_impl(self):
    # Provide a descriptive text for the cell
    return "Circles (d=" + str(self.d) + ",W=" + ('%.3f' % self.w) + ")"

  def produce_impl(self):
    Create.concentric_circles(shapes = self.cell.shapes(self.l_layer), n = self.n, w = self.w, d = self.d, np = self.np)

class Concentric_Squares(pya.PCellDeclarationHelper):
  """
  The PCell declaration for the Lines_Arc_Hats
  """

  def __init__(self):

    # Important: initialize the super class
    super(Concentric_Squares, self).__init__()

    # declare the parameters
    self.param("l", self.TypeLayer, "Layer")
    self.param("s", self.TypeShape, "", default = pya.DPoint(0, 0))
    self.param("n", self.TypeInt, "Number of squares", default = 10)
    self.param("w", self.TypeDouble, "Line width", default = 10)
    self.param("d", self.TypeDouble, "Spacing", default = 10)  
    # this hidden parameter is used to determine whether the radius has changed
    # or the "s" handle has been moved
    self.param("ru", self.TypeDouble, "Radius", default = 0.0, hidden = True)
    self.param("rd", self.TypeDouble, "Double radius", readonly = True)

  def display_text_impl(self):
    # Provide a descriptive text for the cell
    return "Squares (d=" + str(self.d) + ",W=" + ('%.3f' % self.w) + ")"

  def produce_impl(self):
    Create.concentric_squares(shapes = self.cell.shapes(self.l_layer), n = self.n, w = self.w, d = self.d)
    

class Siemens_star(pya.PCellDeclarationHelper):
  """
  The PCell declaration for the Siemens_star
  """

  def __init__(self):

    # Important: initialize the super class
    super(Siemens_star, self).__init__()

    # declare the parameters
    self.param("l", self.TypeLayer, "Layer")
    self.param("s", self.TypeShape, "", default = pya.DPoint(0, 0))
    self.param("r", self.TypeDouble, "Radius", default = 100)
    self.param("n", self.TypeInt, "Number of triangles", default = 32)     
    # this hidden parameter is used to determine whether the radius has changed
    # or the "s" handle has been moved
    self.param("ru", self.TypeDouble, "Radius", default = 0.0, hidden = True)
    self.param("rd", self.TypeDouble, "Double radius", hidden = True)

  def display_text_impl(self):
    # Provide a descriptive text for the cell
    return "Siemens_star(L=" + str(self.l) + ",R=" + ('%.3f' % self.r) + ")"
  
  def coerce_parameters_impl(self):
  
    # We employ coerce_parameters_impl to decide whether the handle or the 
    # numeric parameter has changed (by comparing against the effective 
    # radius ru) and set ru to the effective radius. We also update the 
    # numerical value or the shape, depending on which on has not changed.
    rs = None
    if isinstance(self.s, pya.DPoint): 
      # compute distance in micron
      rs = self.s.distance(pya.DPoint(0, 0))
    if rs != None and abs(self.r-self.ru) &lt; 1e-6:
      self.ru = rs
      self.r = rs 
    else:
      self.ru = self.r
      self.s = pya.DPoint(-self.r, 0)
    
    self.rd = 2*self.r
  
  def can_create_from_shape_impl(self):
    # Implement the "Create PCell from shape" protocol: we can use any shape which 
    # has a finite bounding box
    return self.shape.is_box() or self.shape.is_polygon() or self.shape.is_path()
  
  def parameters_from_shape_impl(self):
    # Implement the "Create PCell from shape" protocol: we set r and l from the shape's 
    # bounding box width and layer
    self.r = self.shape.bbox().width() * self.layout.dbu / 2
    self.l = self.layout.get_info(self.layer)
  
  def transformation_from_shape_impl(self):
    # Implement the "Create PCell from shape" protocol: we use the center of the shape's
    # bounding box to determine the transformation
    return pya.Trans(self.shape.bbox().center())
  
  def produce_impl(self):
    shape = self.cell.shapes(self.l_layer)
    Create.siemens_star(shape, self.n, self.ru)



class Spiral(pya.PCellDeclarationHelper):
  """
  The PCell declaration for a spiral
  """

  def __init__(self):

    # Important: initialize the super class
    super(Spiral, self).__init__()

    # declare the parameters
    self.param("l", self.TypeLayer, "Layer")
    self.param("n", self.TypeInt, "Number of points", default = 64)  
    self.param("inner_r", self.TypeDouble, "Inner Radius", default = 10)	
    self.param("outer_r", self.TypeDouble, "Outer Radius", default = 100)
    self.param("width", self.TypeDouble, "Width", default = 10)
    self.param("spacing", self.TypeDouble, "Spacing", default = 10)
    self.param("inner_handle", self.TypeDouble, "Inner handle", default = pya.DPoint(0,0))	
    self.param("outer_handle", self.TypeDouble, "Outer handle", default = pya.DPoint(0,0))   
    # this hidden parameter is used to determine whether the radius has changed
    # or the "s" handle has been moved
    self.param("inner_mem", self.TypeDouble, "Inner_mem", default = 0.0, hidden = True)
    self.param("outer_mem", self.TypeDouble, "outer_mem", default = 0.0, hidden = True)
  def display_text_impl(self):
    # Provide a descriptive text for the cell
    return "Spiral(L=" + str(self.l) + ",Outer radius=" + ('%.3f' % self.outer_r) + ")"
  

  
  def can_create_from_shape_impl(self):
    # Implement the "Create PCell from shape" protocol: we can use any shape which 
    # has a finite bounding box
    return self.shape.is_box() or self.shape.is_polygon() or self.shape.is_path()
  
  def parameters_from_shape_impl(self):
    # Implement the "Create PCell from shape" protocol: we set r and l from the shape's 
    # bounding box width and layer
    self.inner_r = self.shape.bbox().width() * self.layout.dbu / 4
    self.outer_r = self.shape.bbox().width() * self.layout.dbu / 2   
    self.l = self.layout.get_info(self.layer)
  
  def transformation_from_shape_impl(self):
    # Implement the "Create PCell from shape" protocol: we use the center of the shape's
    # bounding box to determine the transformation
    return pya.Trans(self.shape.bbox().center())
  
  def produce_impl(self):
  
    # This is the main part of the implementation: create the layout
    #fetch parameters
    inner_r_dbu = self.inner_r / self.layout.dbu
    outer_r_dbu = self.outer_r / self.layout.dbu
    # compute the circle
    pts = []
    da = math.pi * 2 / self.n
    dr = (self.width + self.spacing)/self.n/self.layout.dbu
    current_radius = inner_r_dbu
    current_angle = 0
    while current_radius &lt; outer_r_dbu:
      pts.append(pya.Point.from_dpoint(pya.DPoint(current_radius * math.cos(current_angle) , current_radius * math.sin(current_angle))))
      current_radius += dr
      current_angle = (current_angle + da)%(math.pi*2)
    # create the shape
    self.cell.shapes(self.l_layer).insert(pya.Path(pts,self.width/self.layout.dbu))
    
    

class Ruler(pya.PCellDeclarationHelper):
  """
  The PCell declaration for the Ruler
  """

  def __init__(self):

    # Important: initialize the super class
    super(Ruler, self).__init__()

    # declare the parameters
    self.param("l", self.TypeLayer, "Layer")
    self.param("s", self.TypeShape, "", default = pya.DPoint(0, 0))
    self.param("th", self.TypeDouble, "Tooth Height", default = 50)
    self.param("tw", self.TypeDouble, "Tooth Width", default = 10)
    self.param("lw", self.TypeDouble, "Line Width", default = 10)
    self.param("length", self.TypeDouble, "Length", default = 1000)
    self.param("d", self.TypeDouble, "Spacing", default = 100)
    self.param("major", self.TypeInt, "Major ticks", default = 5)
         
    # this hidden parameter is used to determine whether the radius has changed
    # or the "s" handle has been moved
  def display_text_impl(self):
    # Provide a descriptive text for the cell
    return "Ruler(L-=" + str(self.l) + ",Lenth=" + ('%.3f' % self.length) + ")"
  
  
  def can_create_from_shape_impl(self):
    # Implement the "Create PCell from shape" protocol: we can use any shape which 
    # has a finite bounding box
    return self.shape.is_box() or self.shape.is_polygon() or self.shape.is_path()
  
  def parameters_from_shape_impl(self):
    # Implement the "Create PCell from shape" protocol: we set r and l from the shape's 
    # bounding box width and layer
    self.length = self.shape.bbox().width() * self.layout.dbu 
    self.l = self.layout.get_info(self.layer)
  
  def transformation_from_shape_impl(self):
    # Implement the "Create PCell from shape" protocol: we use the center of the shape's
    # bounding box to determine the transformation
    return pya.Trans(self.shape.bbox().center())
  
  def produce_impl(self):
  
    # This is the main part of the implementation: create the layout
    #rotate 90
    t = pya.DTrans(0)
    polygon = Create.ruler( self.th, self.tw, self.lw,self.length,self.d,self.major)
    shapes = self.cell.shapes(self.l_layer)
    shapes.insert(polygon.transform(t))
    
    

    
    
class Vernier(pya.PCellDeclarationHelper):
  """
  The PCell declaration for the Vernier
  """

  def __init__(self):

    # Important: initialize the super class
    super(Vernier, self).__init__()

    # declare the parameters
    self.param("l", self.TypeLayer, "Layer")
    self.param("l2", self.TypeLayer, "Layer 2")
    self.param("s", self.TypeShape, "", default = pya.DPoint(0, 0))
    self.param("height", self.TypeDouble, "Height", default = 100)
    self.param("width", self.TypeDouble, "Width", default = 20)
    self.param("MSD", self.TypeDouble, "Main scale division", default = 100)
    self.param("LC", self.TypeDouble, "Least count", default = 10)
    self.param("overlap", self.TypeDouble, "Overlap", default = 20)
    self.param("offset", self.TypeDouble, "Offset", default = 0)
    self.param("n", self.TypeInt, "Number", default = 11)  
    self.param("mark_center", self.TypeBoolean, "Mark Center", default = True)  


  def display_text_impl(self):
    # Provide a descriptive text for the cell
    return "Vernier(L=" + str(self.l) + ",MSD=" + ('%.3f' % self.MSD) + ")"

  def produce_impl(self):
    # calculate the vernier constant
    VC = self.MSD - self.LC
    shapes1 = self.cell.shapes(self.l_layer)
    shapes2 = self.cell.shapes(self.l2_layer)
    t1 = pya.DTrans(0,False, 0,0)
    t2 = pya.DTrans(2,False, 0 ,self.offset + self.height - self.overlap)
    
    # instantite the the two scales 
    Create.vernier(shapes = shapes1, spacing = self.MSD,width =  self.width,height =  self.height ,n =  self.n, transform = t1,mark_center =  self.mark_center)
    Create.vernier(shapes = shapes2, spacing = VC,width =  self.width, height = self.height, n=  self.n, transform = t2,mark_center = self.mark_center)
    
  
      
class VernierAlign(pya.PCellDeclarationHelper):
  """
  The PCell declaration for the Vernier alignment mark
  """

  def __init__(self):

    # Important: initialize the super class
    super(VernierAlign, self).__init__()

    # declare the parameters
    self.param("l", self.TypeLayer, "Main scale layer")
    self.param("l2", self.TypeLayer, "Vernier scale layer")
    self.param("s", self.TypeShape, "", default = pya.DPoint(0, 0))
    self.param("line_height", self.TypeDouble, "line height", default = 100)
    self.param("line_width", self.TypeDouble, "line width", default = 20)
    self.param("width", self.TypeDouble, "width", default = 1100, hidden = True)
    self.param("msd", self.TypeDouble, "Main scale division", default = 100)
    # Least count is the resolution of the vernier scale
    self.param("lc", self.TypeDouble, "Least count", default = 10)
    self.param("overlap", self.TypeDouble, "Overlap", default = 20)
    self.param("n", self.TypeInt, "Number of markings", default = 11)  
    self.param("mark_center", self.TypeBoolean, "Mark Center", default = True)  
    


  def display_text_impl(self):
    # Provide a descriptive text for the cell
    return "Vernier Align(L=" + str(self.l) + ",MSD=" + ('%.0f' % self.msd) + ",LC=" + ('%.0f' % (self.lc)) +  ")"

  def produce_impl(self):
    Create.vernier_align(shapes1=self.cell.shapes(self.l_layer),shapes2=self.cell.shapes(self.l2_layer), msd=self.msd, lc=self.lc, line_width=self.line_width, line_height=self.line_height, overlap=self.overlap, n = self.n, mark_center=self.mark_center, center_cross = self.mark_center)
    

class Write_area(pya.PCellDeclarationHelper):
  """
  The PCell declaration for the a box equal to the write are
  """

  def __init__(self):

    # Important: initialize the super class
    super(Write_area, self).__init__()

    # declare the parameters
    self.param("l", self.TypeLayer, "Layer 1")
    self.param("obj", self.TypeInt, "Objective", choices = [ [ "0.5x", 0 ], [ "1x", 1 ], [ "2.5x", 2 ], [ "5x", 3 ], [ "10x", 4 ] ], default = 0)


  def display_text_impl(self):
    # Provide a descriptive text for the cell
    
    objname = [ "0.5x","1x","2.5x","5x","10x"]
    return "Write_Area(L=" + str(self.l) + ", obj = " + objname[self.obj] + ")"

  def produce_impl(self):
    obj = self.obj 
    X = [26115.92, 13427, 5331, 2687, 1328]
    Y = [14690.2, 7552, 2998, 1511, 747]
    
    shapes = self.cell.shapes(self.l_layer)
    shapes.insert(pya.DBox(X[obj], Y[obj]))
    
    

class MyLib(pya.Library):
  """
  The library where we will put the PCell into 
  """

  def __init__(self):
  
    # Set the description
    self.description = "Nanomade Test patterns"
    
    # Create the PCell declarations
    self.layout().register_pcell("Siemens_star", Siemens_star())
    self.layout().register_pcell("Spiral", Spiral())
    self.layout().register_pcell("Lines", Lines())
    self.layout().register_pcell("Ruler", Ruler())
    self.layout().register_pcell("Align_default", Align_default())
    self.layout().register_pcell("Vernier", Vernier())
    self.layout().register_pcell("VernierAlign", VernierAlign())
    self.layout().register_pcell("HallBar", HallBar())
    self.layout().register_pcell("Write_area", Write_area())
    self.layout().register_pcell("Lines_Triangle_Hats", Lines_Triangle_Hats())
    self.layout().register_pcell("Lines_Arc_Hats", Lines_Arc_Hats())
    self.layout().register_pcell("Concentric_Circles", Concentric_Circles())
    self.layout().register_pcell("Concentric_Squares", Concentric_Squares())
    # That would be the place to put in more PCells ...
    
    # Register us with the name "TestLib".
    # If a library with that name already existed, it will be replaced then.
    self.register("TestLib")


# Instantiate and register the library
MyLib()</text>
</klayout-macro>
